package themecontroller

import (
	"fmt"

	"github.com/plaenen/webx/ds"
	"github.com/plaenen/webx/utils"
)

// ThemeSignals holds the reactive theme state.
type ThemeSignals struct {
	Theme string `json:"theme"`
}

// ThemeOption represents a selectable theme.
type ThemeOption struct {
	Value string
	Label string
}

// themeEffect returns a Datastar effect expression that applies the current
// theme signal to the document root element.
func themeEffect(signals *utils.SignalManager) string {
	return fmt.Sprintf("document.documentElement.setAttribute('data-theme', %s)", signals.Signal("theme"))
}

// ToggleProps configures a toggle switch between two themes.
type ToggleProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Theme      string // theme to apply when toggled on
	Default    string // theme when toggled off (defaults to "default")
}

templ Toggle(props ToggleProps) {
	{{
		id := props.ID
		if id == "" {
			id = utils.RandomID()
		}
		defaultTheme := props.Default
		if defaultTheme == "" {
			defaultTheme = "default"
		}
		signals := utils.Signals(id, ThemeSignals{Theme: defaultTheme})
	}}
	<input
		type="checkbox"
		value={ props.Theme }
		class={ utils.TwMerge("toggle theme-controller", props.Class) }
		data-signals={ signals.DataSignals }
		{ ds.Effect(themeEffect(signals))... }
		{ ds.On("change", fmt.Sprintf("%s = evt.target.checked ? '%s' : '%s'", signals.Signal("theme"), props.Theme, defaultTheme))... }
		{ ds.Attr("checked", fmt.Sprintf("%s === '%s'", signals.Signal("theme"), props.Theme))... }
		{ props.Attributes... }
	/>
}

// RadioGroupProps configures radio buttons for selecting from multiple themes.
type RadioGroupProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Default    string        // initially selected theme
	Themes     []ThemeOption // available themes
}

templ RadioGroup(props RadioGroupProps) {
	{{
		id := props.ID
		if id == "" {
			id = utils.RandomID()
		}
		defaultTheme := props.Default
		if defaultTheme == "" && len(props.Themes) > 0 {
			defaultTheme = props.Themes[0].Value
		}
		signals := utils.Signals(id, ThemeSignals{Theme: defaultTheme})
		groupName := id + "-radios"
	}}
	<div
		data-signals={ signals.DataSignals }
		{ ds.Effect(themeEffect(signals))... }
		class={ utils.TwMerge("flex flex-col gap-1", props.Class) }
		{ props.Attributes... }
	>
		for _, theme := range props.Themes {
			<label class="label cursor-pointer gap-4">
				<span class="label-text">{ theme.Label }</span>
				<input
					type="radio"
					name={ groupName }
					value={ theme.Value }
					class="radio theme-controller"
					aria-label={ theme.Label }
					{ ds.On("change", signals.Set("theme", "evt.target.value"))... }
					{ ds.Attr("checked", signals.Equals("theme", theme.Value))... }
				/>
			</label>
		}
	</div>
}

// ButtonGroupProps configures a button-strip theme selector.
type ButtonGroupProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Default    string        // initially selected theme
	Themes     []ThemeOption // available themes
}

templ ButtonGroup(props ButtonGroupProps) {
	{{
		id := props.ID
		if id == "" {
			id = utils.RandomID()
		}
		defaultTheme := props.Default
		if defaultTheme == "" && len(props.Themes) > 0 {
			defaultTheme = props.Themes[0].Value
		}
		signals := utils.Signals(id, ThemeSignals{Theme: defaultTheme})
		groupName := id + "-btns"
	}}
	<div
		data-signals={ signals.DataSignals }
		{ ds.Effect(themeEffect(signals))... }
		class={ utils.TwMerge("join", props.Class) }
		{ props.Attributes... }
	>
		for _, theme := range props.Themes {
			<input
				type="radio"
				name={ groupName }
				value={ theme.Value }
				class="btn theme-controller join-item"
				aria-label={ theme.Label }
				{ ds.On("change", signals.Set("theme", "evt.target.value"))... }
				{ ds.Attr("checked", signals.Equals("theme", theme.Value))... }
			/>
		}
	</div>
}
